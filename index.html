<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shader Viewer for Yewon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
        }

        #editor-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #333;
        }

        #editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #controls {
            background: #252526;
            padding: 10px;
            border-bottom: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 50vh;
            overflow-y: auto;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        /* 파라미터 컨트롤 */
        #params-container {
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 4px;
            padding: 8px;
            display: none;
        }

        #params-container.has-params {
            display: block;
        }

        .param-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        .param-label {
            min-width: 100px;
            font-size: 12px;
            color: #4ec9b0;
        }

        .param-slider {
            flex: 1;
            min-width: 100px;
        }

        .param-value {
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .param-reset {
            background: #3c3c3c;
            color: #d4d4d4;
            border: none;
            padding: 2px 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 11px;
        }

        .param-reset:hover {
            background: #4c4c4c;
        }

        #controls button {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            margin-right: 8px;
            cursor: pointer;
            border-radius: 3px;
            font-size: 13px;
        }

        #controls button:hover {
            background: #1177bb;
        }

        #controls button.recording {
            background: #d9534f;
        }

        #controls input,
        #controls select {
            background: #3c3c3c;
            color: #d4d4d4;
            border: 1px solid #555;
            padding: 6px 10px;
            margin-right: 8px;
            border-radius: 3px;
            font-size: 13px;
        }

        #controls label {
            margin-right: 5px;
            font-size: 13px;
        }

        #shader-code {
            flex: 1;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            outline: none;
        }

        /* 카드 슬라이더 */
        #cards-container {
            background: #252526;
            border-top: 1px solid #333;
            padding: 12px 0;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
        }

        #cards-slider {
            display: inline-flex;
            gap: 12px;
            padding: 0 12px;
        }

        .shader-card {
            display: inline-block;
            width: 160px;
            height: 120px;
            background: #1e1e1e;
            border: 2px solid #3c3c3c;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            vertical-align: top;
            flex-shrink: 0;
        }

        .shader-card:hover {
            border-color: #0e639c;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .shader-card.active {
            border-color: #4ec9b0;
            background: #2d2d30;
        }

        .shader-card.add-card {
            border: 2px dashed #555;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            color: #858585;
        }

        .shader-card.add-card:hover {
            border-color: #0e639c;
            color: #d4d4d4;
        }

        .card-preview {
            width: 100%;
            height: 60px;
            background: #0a0a0a;
            border-radius: 4px;
            margin-bottom: 8px;
            overflow: hidden;
            position: relative;
        }

        .card-preview canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .card-name {
            font-size: 12px;
            color: #d4d4d4;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-bottom: 4px;
        }

        .card-date {
            font-size: 10px;
            color: #858585;
        }

        .card-delete {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(217, 83, 79, 0.9);
            color: white;
            border: none;
            border-radius: 3px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            display: none;
        }

        .shader-card:hover .card-delete {
            display: block;
        }

        .card-delete:hover {
            background: #c9302c;
        }

        .add-icon {
            font-size: 32px;
            margin-bottom: 4px;
        }

        #viewer-panel {
            width: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #2d2d30;
            position: relative;
        }

        #canvas {
            max-width: 100%;
            max-height: 100%;
            image-rendering: pixelated;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
        }

        #error {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(211, 47, 47, 0.9);
            color: white;
            padding: 12px;
            border-radius: 4px;
            font-size: 12px;
            display: none;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="editor-panel">
            <div id="editor-container">
                <div id="controls">
                    <div class="control-row">
                        <button id="compile-btn">컴파일 (Ctrl+Enter)</button>
                        <button id="reset-btn">시간 리셋</button>
                    </div>

                    <div id="params-container"></div>

                    <div class="control-row">
                        <label>해상도:</label>
                        <input type="number" id="width" value="1920" min="256" max="7680" step="1">
                        <span>×</span>
                        <input type="number" id="height" value="1080" min="256" max="4320" step="1">
                        <button id="apply-res-btn">적용</button>
                    </div>

                    <div class="control-row">
                        <label>FPS:</label>
                        <select id="fps">
                            <option value="30">30</option>
                            <option value="60" selected>60</option>
                            <option value="120">120</option>
                        </select>
                    </div>

                    <div class="control-row">
                        <label>녹화 시작 시간:</label>
                        <input type="number" id="record-start" value="0" min="0" step="0.1" style="width: 80px;">
                        <span>초</span>
                        <label style="margin-left: 15px;">녹화 길이:</label>
                        <input type="number" id="record-duration" value="10" min="0.1" step="0.1" style="width: 80px;">
                        <span>초</span>
                        <label style="margin-left: 10px;">
                            <input type="checkbox" id="auto-stop">
                            자동 중지
                        </label>
                    </div>

                    <div class="control-row">
                        <button id="record-btn">녹화 시작</button>
                        <button id="record-reset-btn">0초부터 녹화</button>
                        <button id="download-btn" style="display: none;">다운로드</button>
                        <span id="record-status" style="color: #888; margin-left: 10px;"></span>
                    </div>
                    <!-- <div
                        style="background-color: rgba(255, 255, 255, 0.2); color: #c8c8c8; font-size: small; padding: 10px; text-align: left;">

                        // #pragma param 이름 최소값 최대값 기본값 [step]
                        <br>
                        #pragma param speed 0.0 5.0 1.0 0.1
                    </div> -->
                </div>

                <textarea id="shader-code" spellcheck="false">
// WebGL 2.0 GLSL 300 es 지원

// 파라미터 정의: #pragma param 이름 최소값 최대값 기본값 [step]
#pragma param speed 0.0 5.0 1.0 0.1
#pragma param radius 0.1 1.0 0.5 0.01
#pragma param intensity 0.0 2.0 1.0 0.05

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // 정규화된 좌표 (0.0 ~ 1.0)
    vec2 uv = fragCoord / iResolution.xy;
    
    // 중심 기준 좌표 (-1.0 ~ 1.0)
    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;
    
    // 시간에 따라 변하는 색상 (speed 파라미터 사용)
    vec3 col = 0.5 + 0.5 * cos(iTime * speed + uv.xyx + vec3(0, 2, 4));
    
    // 원 그리기 (radius와 intensity 파라미터 사용)
    float d = length(p) - radius;
    d = sin(d * 8.0 + iTime * speed) / 8.0;
    d = abs(d);
    d = 0.02 / d;
    
    col *= d * intensity;
    
    fragColor = vec4(col, 1.0);
}</textarea>
            </div>

            <div id="cards-container">
                <div id="cards-slider"></div>
            </div>
        </div>

        <div id="viewer-panel">
            <canvas id="canvas"></canvas>
            <div id="info">
                <div>FPS: <span id="fps-counter">0</span></div>
                <div>시간: <span id="time-counter">0.00</span>s</div>
                <div>해상도: <span id="resolution-info">1920×1080</span></div>
            </div>
            <div id="error"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2.0을 지원하지 않는 브라우저입니다. 최신 브라우저를 사용해주세요.');
            throw new Error('WebGL 2.0 not supported');
        }
        const shaderCode = document.getElementById('shader-code');
        const errorDiv = document.getElementById('error');
        const fpsCounter = document.getElementById('fps-counter');
        const timeCounter = document.getElementById('time-counter');
        const resolutionInfo = document.getElementById('resolution-info');

        let program = null;
        let startTime = Date.now();
        let frameCount = 0;
        let lastFpsTime = Date.now();
        let currentFps = 0;

        // 녹화 관련 변수
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recordingStartTime = 0;
        let recordingTargetDuration = 0;
        let autoStopEnabled = false;

        // 파라미터 관리
        let shaderParams = {};
        let paramUniforms = {};

        // 기본 해상도 설정
        function setResolution(width, height) {
            canvas.width = width;
            canvas.height = height;
            resolutionInfo.textContent = `${width}×${height}`;
            gl.viewport(0, 0, width, height);
        }

        setResolution(1920, 1080);

        // Vertex Shader (전체 화면을 덮는 삼각형)
        const vertexShaderSource = `#version 300 es
            in vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        // Fragment Shader 직접 사용
        function buildFragmentShader(userCode) {
            // WebGL 2.0 GLSL 300 es 버전 사용
            // Shadertoy 스타일 코드를 그대로 지원
            if (userCode.includes('void mainImage')) {
                return `#version 300 es
                    precision highp float;
                    uniform vec2 iResolution;
                    uniform float iTime;
                    uniform vec4 iMouse;
                    uniform int iFrame;
                    
                    ${generateParamUniforms()}
                    
                    out vec4 fragColor;
                    
                    ${userCode}
                    
                    void main() {
                        mainImage(fragColor, gl_FragCoord.xy);
                    }
                `;
            }

            // void main()이 있으면 그대로 사용
            if (userCode.includes('void main()')) {
                // GLSL 300 es 버전이 없으면 추가
                if (!userCode.includes('#version 300 es')) {
                    return `#version 300 es\n${generateParamUniforms()}\n${userCode}`;
                }
                return userCode;
            }

            // 둘 다 없으면 기본 래퍼 제공
            return `#version 300 es
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform int iFrame;
                
                ${generateParamUniforms()}
                
                out vec4 fragColor;
                
                ${userCode}
            `;
        }

        // 파라미터 유니폼 생성
        function generateParamUniforms() {
            return Object.keys(shaderParams).map(name => {
                return `uniform float ${name};`;
            }).join('\n');
        }

        // 코드에서 파라미터 추출
        function parseParameters(code) {
            const params = {};
            // #pragma param name min max default [step]
            const regex = /#pragma\s+param\s+(\w+)\s+([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)(?:\s+([-\d.]+))?/g;
            let match;

            while ((match = regex.exec(code)) !== null) {
                const [, name, min, max, defaultVal, step] = match;
                params[name] = {
                    name: name,
                    min: parseFloat(min),
                    max: parseFloat(max),
                    default: parseFloat(defaultVal),
                    value: parseFloat(defaultVal),
                    step: step ? parseFloat(step) : (parseFloat(max) - parseFloat(min)) / 100
                };
            }

            return params;
        }

        // 파라미터 UI 생성
        function updateParameterUI() {
            const container = document.getElementById('params-container');
            shaderParams = parseParameters(shaderCode.value);

            if (Object.keys(shaderParams).length === 0) {
                container.classList.remove('has-params');
                container.innerHTML = '';
                return;
            }

            container.classList.add('has-params');
            container.innerHTML = '<div style="font-size: 11px; color: #858585; margin-bottom: 8px;">쉐이더 파라미터</div>' +
                Object.keys(shaderParams).map(name => {
                    const p = shaderParams[name];
                    return `
                        <div class="param-control">
                            <span class="param-label">${name}</span>
                            <input type="range" 
                                   class="param-slider" 
                                   id="param-${name}"
                                   min="${p.min}" 
                                   max="${p.max}" 
                                   step="${p.step}" 
                                   value="${p.value}">
                            <span class="param-value" id="value-${name}">${p.value.toFixed(2)}</span>
                            <button class="param-reset" onclick="resetParam('${name}')">↺</button>
                        </div>
                    `;
                }).join('');

            // 슬라이더 이벤트 리스너 추가
            Object.keys(shaderParams).forEach(name => {
                const slider = document.getElementById(`param-${name}`);
                const valueDisplay = document.getElementById(`value-${name}`);

                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    shaderParams[name].value = value;
                    valueDisplay.textContent = value.toFixed(2);
                });
            });
        }

        // 파라미터 리셋
        function resetParam(name) {
            if (shaderParams[name]) {
                const defaultVal = shaderParams[name].default;
                shaderParams[name].value = defaultVal;

                const slider = document.getElementById(`param-${name}`);
                const valueDisplay = document.getElementById(`value-${name}`);

                if (slider) slider.value = defaultVal;
                if (valueDisplay) valueDisplay.textContent = defaultVal.toFixed(2);
            }
        }

        // 쉐이더 컴파일
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const error = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error(error);
            }

            return shader;
        }

        // 미리보기용 쉐이더 컴파일 (에러 발생시 null 반환)
        function compileShaderForPreview(source, type, context) {
            if (!context) return null;

            try {
                const shader = context.createShader(type);
                context.shaderSource(shader, source);
                context.compileShader(shader);

                if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
                    context.deleteShader(shader);
                    return null;
                }

                return shader;
            } catch (e) {
                return null;
            }
        }

        // 프로그램 생성
        function createProgram(userFragmentCode) {
            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(
                buildFragmentShader(userFragmentCode),
                gl.FRAGMENT_SHADER
            );

            const newProgram = gl.createProgram();
            gl.attachShader(newProgram, vertexShader);
            gl.attachShader(newProgram, fragmentShader);
            gl.linkProgram(newProgram);

            if (!gl.getProgramParameter(newProgram, gl.LINK_STATUS)) {
                const error = gl.getProgramInfoLog(newProgram);
                gl.deleteProgram(newProgram);
                throw new Error(error);
            }

            return newProgram;
        }

        // 전체 화면 삼각형 버퍼 생성
        const vertices = new Float32Array([
            -1, -1,
            3, -1,
            -1, 3
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // 마우스 위치 추적
        let mouseX = 0,
            mouseY = 0;
        let mouseDown = false;

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = canvas.height - (e.clientY - rect.top);
        });

        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);

        // 렌더링 루프
        let animationId = null;

        function render() {
            if (!program) return;

            const currentTime = (Date.now() - startTime) / 1000.0;

            // 자동 녹화 중지 체크
            if (isRecording && autoStopEnabled) {
                const recordingElapsed = currentTime - recordingStartTime;
                if (recordingElapsed >= recordingTargetDuration) {
                    stopRecording();
                }

                // 녹화 상태 표시
                const remaining = Math.max(0, recordingTargetDuration - recordingElapsed);
                document.getElementById('record-status').textContent =
                    `녹화 중... (${recordingElapsed.toFixed(1)}s / ${recordingTargetDuration.toFixed(1)}s)`;
            }

            gl.useProgram(program);

            // Uniforms 설정
            const iResolutionLoc = gl.getUniformLocation(program, 'iResolution');
            const iTimeLoc = gl.getUniformLocation(program, 'iTime');
            const iMouseLoc = gl.getUniformLocation(program, 'iMouse');
            const iFrameLoc = gl.getUniformLocation(program, 'iFrame');

            gl.uniform2f(iResolutionLoc, canvas.width, canvas.height);
            gl.uniform1f(iTimeLoc, currentTime);
            gl.uniform4f(iMouseLoc, mouseX, mouseY, mouseDown ? 1 : 0, 0);
            gl.uniform1i(iFrameLoc, frameCount);

            // 파라미터 유니폼 전달
            Object.keys(shaderParams).forEach(name => {
                const loc = gl.getUniformLocation(program, name);
                if (loc !== null) {
                    gl.uniform1f(loc, shaderParams[name].value);
                }
            });

            // Position attribute 설정
            const positionLoc = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

            // 그리기
            gl.drawArrays(gl.TRIANGLES, 0, 3);

            // FPS 계산
            frameCount++;
            const now = Date.now();
            if (now - lastFpsTime >= 1000) {
                currentFps = frameCount;
                fpsCounter.textContent = currentFps;
                frameCount = 0;
                lastFpsTime = now;
            }

            timeCounter.textContent = currentTime.toFixed(2);

            animationId = requestAnimationFrame(render);
        }

        // 초기 컴파일
        compileAndRun();

        // 이벤트 리스너
        document.getElementById('compile-btn').addEventListener('click', compileAndRun);

        document.getElementById('reset-btn').addEventListener('click', () => {
            startTime = Date.now();
            frameCount = 0;
        });

        document.getElementById('apply-res-btn').addEventListener('click', () => {
            const width = parseInt(document.getElementById('width').value);
            const height = parseInt(document.getElementById('height').value);
            setResolution(width, height);
        });

        // 키보드 단축키
        shaderCode.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                compileAndRun();
            }

            // Tab 키 처리
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = shaderCode.selectionStart;
                const end = shaderCode.selectionEnd;
                shaderCode.value = shaderCode.value.substring(0, start) + '    ' + shaderCode.value.substring(
                    end);
                shaderCode.selectionStart = shaderCode.selectionEnd = start + 4;
            }
        });

        // LocalStorage 관리
        const STORAGE_KEY = 'shader-codes';
        let currentCardId = null;

        function getSavedCodes() {
            const saved = localStorage.getItem(STORAGE_KEY);
            return saved ? JSON.parse(saved) : [];
        }

        function setSavedCodes(codes) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(codes));
        }

        function generateCardName() {
            const now = new Date();
            return `Shader ${now.getMonth() + 1}/${now.getDate()} ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
        }

        // 컴파일 시 자동 저장
        function compileAndRun() {
            try {
                // 파라미터 UI 업데이트
                updateParameterUI();

                const newProgram = createProgram(shaderCode.value);

                if (program) {
                    gl.deleteProgram(program);
                }

                program = newProgram;
                errorDiv.style.display = 'none';

                if (!animationId) {
                    render();
                }

                // 컴파일 성공 시 자동 저장
                autoSaveCurrentCode();

            } catch (error) {
                errorDiv.textContent = '쉐이더 컴파일 오류:\n' + error.message;
                errorDiv.style.display = 'block';
            }
        }

        function autoSaveCurrentCode() {
            const codes = getSavedCodes();
            const code = shaderCode.value;

            if (currentCardId) {
                // 기존 카드 업데이트
                const index = codes.findIndex(c => c.id === currentCardId);
                if (index !== -1) {
                    codes[index].code = code;
                    codes[index].date = new Date().toISOString();
                    setSavedCodes(codes);
                    renderCards();
                    return;
                }
            }

            // 새 카드 생성
            const newCode = {
                id: Date.now(),
                name: generateCardName(),
                code: code,
                date: new Date().toISOString()
            };

            codes.push(newCode);
            setSavedCodes(codes);
            currentCardId = newCode.id;
            renderCards();
        }

        function renderCards() {
            const codes = getSavedCodes();
            const slider = document.getElementById('cards-slider');

            // 최신순 정렬
            codes.sort((a, b) => b.id - a.id);

            slider.innerHTML = codes.map(item => `
                <div class="shader-card ${item.id === currentCardId ? 'active' : ''}" onclick="loadCard(${item.id})">
                    <button class="card-delete" onclick="event.stopPropagation(); deleteCard(${item.id})">×</button>
                    <div class="card-preview" id="preview-${item.id}"></div>
                    <div class="card-name" title="${escapeHtml(item.name)}">${escapeHtml(item.name)}</div>
                    <div class="card-date">${formatDate(item.date)}</div>
                </div>
            `).join('') + `
                <div class="shader-card add-card" onclick="createNewCard()">
                    <div class="add-icon">+</div>
                    <div>새 쉐이더</div>
                </div>
            `;

            // 미리보기 캔버스 생성
            setTimeout(() => {
                codes.forEach(item => {
                    const previewDiv = document.getElementById(`preview-${item.id}`);
                    if (previewDiv && !previewDiv.querySelector('canvas')) {
                        createPreviewCanvas(previewDiv, item.code);
                    }
                });
            }, 0);
        }

        function createPreviewCanvas(container, code) {
            const canvas = document.createElement('canvas');
            canvas.width = 160;
            canvas.height = 60;
            container.appendChild(canvas);

            try {
                const ctx = canvas.getContext('webgl2');
                if (!ctx) {
                    console.warn('WebGL2 not available for preview');
                    return;
                }

                const vertShader = compileShaderForPreview(`#version 300 es
                    in vec2 position;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `, ctx.VERTEX_SHADER, ctx);

                if (!vertShader) return;

                const fragShader = compileShaderForPreview(
                    buildFragmentShader(code),
                    ctx.FRAGMENT_SHADER,
                    ctx
                );

                if (!fragShader) return;

                const prog = ctx.createProgram();
                ctx.attachShader(prog, vertShader);
                ctx.attachShader(prog, fragShader);
                ctx.linkProgram(prog);

                if (!ctx.getProgramParameter(prog, ctx.LINK_STATUS)) {
                    return;
                }

                const buf = ctx.createBuffer();
                ctx.bindBuffer(ctx.ARRAY_BUFFER, buf);
                ctx.bufferData(ctx.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), ctx.STATIC_DRAW);

                ctx.useProgram(prog);
                ctx.uniform2f(ctx.getUniformLocation(prog, 'iResolution'), 160, 60);
                ctx.uniform1f(ctx.getUniformLocation(prog, 'iTime'), 0);
                ctx.uniform4f(ctx.getUniformLocation(prog, 'iMouse'), 0, 0, 0, 0);
                ctx.uniform1i(ctx.getUniformLocation(prog, 'iFrame'), 0);

                const posLoc = ctx.getAttribLocation(prog, 'position');
                ctx.enableVertexAttribArray(posLoc);
                ctx.vertexAttribPointer(posLoc, 2, ctx.FLOAT, false, 0, 0);

                ctx.viewport(0, 0, 160, 60);
                ctx.drawArrays(ctx.TRIANGLES, 0, 3);
            } catch (e) {
                console.warn('Preview generation failed:', e);
            }
        }

        function compileShaderForPreview(source, type, context) {
            if (!context) return null;

            try {
                const shader = context.createShader(type);
                context.shaderSource(shader, source);
                context.compileShader(shader);

                if (!context.getShaderParameter(shader, context.COMPILE_STATUS)) {
                    context.deleteShader(shader);
                    return null;
                }

                return shader;
            } catch (e) {
                return null;
            }
        }

        function loadCard(id) {
            const codes = getSavedCodes();
            const code = codes.find(c => c.id === id);

            if (code) {
                shaderCode.value = code.code;
                currentCardId = id;
                renderCards();
                compileAndRun();
            }
        }

        function deleteCard(id) {
            if (!confirm('이 쉐이더를 삭제하시겠습니까?')) return;

            const codes = getSavedCodes();
            const filtered = codes.filter(c => c.id !== id);
            setSavedCodes(filtered);

            if (currentCardId === id) {
                if (filtered.length > 0) {
                    loadCard(filtered[0].id);
                } else {
                    currentCardId = null;
                    shaderCode.value = '// 새 쉐이더를 작성하세요';
                }
            }

            renderCards();
        }

        function createNewCard() {
            const newCode = {
                id: Date.now(),
                name: generateCardName(),
                code: '// 새 쉐이더\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(uv, 0.5, 1.0);\n}',
                date: new Date().toISOString()
            };

            const codes = getSavedCodes();
            codes.push(newCode);
            setSavedCodes(codes);

            loadCard(newCode.id);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatDate(isoString) {
            const date = new Date(isoString);
            const now = new Date();
            const diff = now - date;

            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);

            if (minutes < 1) return '방금 전';
            if (minutes < 60) return `${minutes}분 전`;
            if (hours < 24) return `${hours}시간 전`;
            if (days < 7) return `${days}일 전`;

            return date.toLocaleDateString('ko-KR', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        // 초기 카드 렌더링
        renderCards();

        // 기존 데이터가 있으면 첫 번째 카드 로드
        const savedCodes = getSavedCodes();
        if (savedCodes.length > 0) {
            loadCard(savedCodes[savedCodes.length - 1].id);
        }

        // 녹화 기능
        document.getElementById('record-btn').addEventListener('click', () => {
            if (!isRecording) {
                const startFrom = parseFloat(document.getElementById('record-start').value);
                startRecordingAt(startFrom);
            } else {
                stopRecording();
            }
        });

        document.getElementById('record-reset-btn').addEventListener('click', () => {
            // 시간 리셋하고 즉시 녹화 시작
            startTime = Date.now();
            frameCount = 0;
            startRecordingAt(0);
        });

        function startRecordingAt(startFrom) {
            const currentTime = (Date.now() - startTime) / 1000.0;

            autoStopEnabled = document.getElementById('auto-stop').checked;
            recordingTargetDuration = parseFloat(document.getElementById('record-duration').value);

            // 시작 시간으로 타임라인 이동
            if (currentTime < startFrom) {
                // 미래 시간으로 시간 이동
                startTime = Date.now() - (startFrom * 1000);
                const waitTime = 0.1; // 즉시 시작 (프레임 대기)
                document.getElementById('record-status').textContent =
                    `${startFrom.toFixed(1)}초로 이동 중...`;

                setTimeout(() => {
                    startRecording();
                }, waitTime * 1000);
            } else if (currentTime > startFrom) {
                // 과거 시간으로 되돌리기
                startTime = Date.now() - (startFrom * 1000);
                document.getElementById('record-status').textContent =
                    `${startFrom.toFixed(1)}초로 이동 중...`;

                setTimeout(() => {
                    startRecording();
                }, 100);
            } else {
                // 정확히 현재 시간
                startRecording();
            }
        }

        function startRecording() {
            const fps = parseInt(document.getElementById('fps').value);
            const stream = canvas.captureStream(fps);

            recordedChunks = [];
            recordingStartTime = (Date.now() - startTime) / 1000.0;

            // MP4 (H.264) 시도, 지원 안 하면 WebM으로 폴백
            let options = {
                mimeType: 'video/mp4;codecs=avc1',
                videoBitsPerSecond: 25000000 // 25 Mbps for high quality
            };

            let fileExtension = 'mp4';
            let mimeType = 'video/mp4';

            if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                // MP4 안 되면 WebM VP9 시도
                options.mimeType = 'video/webm;codecs=vp9';
                fileExtension = 'webm';
                mimeType = 'video/webm';

                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    // VP9도 안 되면 VP8
                    options.mimeType = 'video/webm;codecs=vp8';
                }
            }

            mediaRecorder = new MediaRecorder(stream, options);

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    recordedChunks.push(event.data);
                }
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, {
                    type: mimeType
                });
                const url = URL.createObjectURL(blob);

                const downloadBtn = document.getElementById('download-btn');
                downloadBtn.style.display = 'inline-block';
                downloadBtn.onclick = () => {
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `shader-recording-${Date.now()}.${fileExtension}`;
                    a.click();
                };

                document.getElementById('record-status').textContent = '녹화 완료!';
                setTimeout(() => {
                    document.getElementById('record-status').textContent = '';
                }, 3000);
            };

            mediaRecorder.start();
            isRecording = true;

            const recordBtn = document.getElementById('record-btn');
            recordBtn.textContent = '녹화 중지';
            recordBtn.classList.add('recording');

            if (!autoStopEnabled) {
                document.getElementById('record-status').textContent = '녹화 중...';
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            isRecording = false;
            autoStopEnabled = false;

            const recordBtn = document.getElementById('record-btn');
            recordBtn.textContent = '녹화 시작';
            recordBtn.classList.remove('recording');
        }
    </script>
</body>

</html>